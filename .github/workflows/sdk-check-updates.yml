name: Check Portal SDK Updates

on:
  push:
    branches: [main]
  workflow_dispatch:
  repository_dispatch:
    types: [check-sdk-updates]
  schedule:
    # Monday: Every hour 8-20 UTC
    - cron: '0 8-20 * * 1'
    # Tuesday: Every hour 8-20 UTC
    - cron: '0 8-20 * * 2'
    # Wednesday-Friday: Every 4 hours (boost mode will override)
    - cron: '0 */4 * * 3-5'
    # Saturday-Sunday: Every 6 hours
    - cron: '0 */6 * * 0,6'
    # Normal boost check: Every hour on weekdays
    - cron: '0 * * * 1-5'
    # Aggressive boost check: Every 30 minutes on weekdays
    - cron: '*/30 * * * 1-5'

permissions:
  contents: write
  issues: write

jobs:
  check-and-update:
    name: Check and Update SDK
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Detect trigger type
        id: trigger
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "is_manual=true" >> $GITHUB_OUTPUT
            echo "üîß Manual trigger detected - bypassing schedule checks"
          else
            echo "is_manual=false" >> $GITHUB_OUTPUT
            echo "‚è∞ Automatic trigger - following schedule"
          fi
      
      - name: Check for recent game updates (Tiered)
        if: steps.trigger.outputs.is_manual == 'false'
        id: game_update
        run: |
          echo "üéÆ Checking for recent Battlefield game updates (Tiered Detection)..."
          
          mkdir -p .github/cache
          CACHE_FILE=".github/cache/game-update-tracker.json"
          STEAMDB_URL="https://steamdb.info/app/2807960/history/"
          EA_NEWS_URL="https://www.ea.com/games/battlefield/battlefield-6/news?page=1&type=game-updates"
          
          BOOST_MODE="none"
          BOOST_LEVEL="none"
          BOOST_REASON="No recent game update detected"
          CURRENT_TIME=$(date -u +%s)
          
          # Initialize cache if not exists
          if [ ! -f "$CACHE_FILE" ]; then
            cat > "$CACHE_FILE" << 'EOF'
          {
            "steamdb": {
              "last_update_date": "2000-01-01T00:00:00Z",
              "game_version": "unknown",
              "build_id": "unknown",
              "manual_trigger": false
            },
            "ea_blog": {
              "last_update_date": "2000-01-01T00:00:00Z",
              "title": "unknown"
            },
            "sdk": {
              "last_update_date": "2000-01-01T00:00:00Z",
              "version": "unknown",
              "matched_game_version": "unknown"
            },
            "last_check_date": "2000-01-01T00:00:00Z"
          }
          EOF
          fi
          
          # Load cached data
          STEAMDB_LAST=$(jq -r '.steamdb.last_update_date // "2000-01-01T00:00:00Z"' "$CACHE_FILE")
          EA_LAST=$(jq -r '.ea_blog.last_update_date // "2000-01-01T00:00:00Z"' "$CACHE_FILE")
          GAME_VERSION=$(jq -r '.steamdb.game_version // "unknown"' "$CACHE_FILE")
          
          # === TIER 1: SteamDB Check (Aggressive Boost - 8 hours) ===
          echo "üîç Tier 1: Checking SteamDB update timestamp..."
          STEAMDB_TIME=$(date -d "$STEAMDB_LAST" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$STEAMDB_LAST" +%s 2>/dev/null || echo "0")
          
          if [ "$STEAMDB_TIME" != "0" ]; then
            HOURS_SINCE_STEAMDB=$((($CURRENT_TIME - $STEAMDB_TIME) / 3600))
            echo "   Hours since SteamDB update: $HOURS_SINCE_STEAMDB"
            
            if [ "$HOURS_SINCE_STEAMDB" -lt 8 ]; then
              BOOST_MODE="active"
              BOOST_LEVEL="aggressive"
              BOOST_REASON="SteamDB game update $HOURS_SINCE_STEAMDB hours ago (v$GAME_VERSION)"
            fi
          fi
          
          # Try to fetch SteamDB (may be blocked - 403)
          STEAMDB_HTML=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" "$STEAMDB_URL" 2>/dev/null || echo "")
          if [ -n "$STEAMDB_HTML" ] && ! echo "$STEAMDB_HTML" | grep -qi "403\|forbidden\|access denied"; then
            # Look for recent version updates (basic pattern matching)
            TODAY=$(date -u +%Y-%m-%d)
            YESTERDAY=$(date -u -d "yesterday" +%Y-%m-%d 2>/dev/null || date -u -v-1d +%Y-%m-%d 2>/dev/null)
            
            if echo "$STEAMDB_HTML" | grep -E "$TODAY|$YESTERDAY" | grep -qi "version\|build\|update"; then
              BOOST_MODE="active"
              BOOST_LEVEL="aggressive"
              BOOST_REASON="New SteamDB update detected"
              
              # Update cache with new detection
              jq ".steamdb.last_update_date = \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\" | .steamdb.manual_trigger = false" "$CACHE_FILE" > "$CACHE_FILE.tmp" && mv "$CACHE_FILE.tmp" "$CACHE_FILE"
            fi
          else
            echo "   ‚ö†Ô∏è  SteamDB blocked or inaccessible (using cached data)"
          fi
          
          # === TIER 2: EA Blog Check (Normal Boost - 72 hours) ===
          if [ "$BOOST_LEVEL" != "aggressive" ]; then
            echo "üîç Tier 2: Checking EA blog update timestamp..."
            EA_TIME=$(date -d "$EA_LAST" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$EA_LAST" +%s 2>/dev/null || echo "0")
            
            if [ "$EA_TIME" != "0" ]; then
              HOURS_SINCE_EA=$((($CURRENT_TIME - $EA_TIME) / 3600))
              echo "   Hours since EA blog update: $HOURS_SINCE_EA"
              
              if [ "$HOURS_SINCE_EA" -lt 72 ]; then
                BOOST_MODE="active"
                BOOST_LEVEL="normal"
                BOOST_REASON="EA blog update $HOURS_SINCE_EA hours ago"
                echo "   üîî NORMAL BOOST ACTIVE (EA Blog)"
              fi
            fi
            
            # Try to fetch EA news page
            EA_HTML=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" "$EA_NEWS_URL" 2>/dev/null || echo "")
            
            if [ -n "$EA_HTML" ]; then
              # Look for portal/sdk mentions with recent dates
              if echo "$EA_HTML" | grep -qi "portal\|sdk"; then
                TODAY=$(date -u +%Y-%m-%d)
                YESTERDAY=$(date -u -d "yesterday" +%Y-%m-%d 2>/dev/null || date -u -v-1d +%Y-%m-%d 2>/dev/null)
                
                if echo "$EA_HTML" | grep -qi "$TODAY\|$YESTERDAY"; then

                  BOOST_LEVEL="normal"
                  BOOST_REASON="New EA blog update detected"
                  
                  # Update cache
                  jq ".ea_blog.last_update_date = \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"" "$CACHE_FILE" > "$CACHE_FILE.tmp" && mv "$CACHE_FILE.tmp" "$CACHE_FILE"
                fi
              fi
            fi
          fi
          
          # Update last check time
          jq ".last_check_date = \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"" "$CACHE_FILE" > "$CACHE_FILE.tmp" && mv "$CACHE_FILE.tmp" "$CACHE_FILE"
          
          # Output results
          echo "boost_mode=$BOOST_MODE" >> $GITHUB_OUTPUT
          echo "boost_level=$BOOST_LEVEL" >> $GITHUB_OUTPUT
          echo "boost_reason=$BOOST_REASON" >> $GITHUB_OUTPUT
          echo "game_version=$GAME_VERSION" >> $GITHUB_OUTPUT
          
          echo ""
          echo "=========================================="
          echo "üöÄ Boost Status: $BOOST_MODE"
          echo "üìä Boost Level: $BOOST_LEVEL"
          echo "üí° Reason: $BOOST_REASON"
          echo "üéÆ Game Version: $GAME_VERSION"
          echo "=========================================="
      
      - name: Set default game update outputs (manual trigger)
        if: steps.trigger.outputs.is_manual == 'true'
        id: game_update_defaults
        run: |
          echo "boost_mode=none" >> $GITHUB_OUTPUT
          echo "boost_level=none" >> $GITHUB_OUTPUT
          echo "boost_reason=Manual trigger" >> $GITHUB_OUTPUT
          echo "game_version=unknown" >> $GITHUB_OUTPUT
      
      - name: Check work hours (Mon/Tue only)
        id: work_hours
        run: |
          IS_MANUAL="${{ steps.trigger.outputs.is_manual }}"
          
          # Manual trigger: Always run immediately
          if [ "$IS_MANUAL" = "true" ]; then
            echo "üîß Manual trigger - bypassing all schedule checks"
            echo "should_run=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          HOUR=$(date -u +%H | sed 's/^0//')
          DAY=$(date -u +%u)
          BOOST_MODE="${{ steps.game_update.outputs.boost_mode || 'none' }}"
          BOOST_LEVEL="${{ steps.game_update.outputs.boost_level || 'none' }}"
          
          echo "Current hour (UTC): $HOUR"
          echo "Day of week: $DAY (1=Mon, 7=Sun)"
          echo "Boost mode: $BOOST_MODE"
          echo "Boost level: $BOOST_LEVEL"
          
          SHOULD_RUN="true"
          
          # Aggressive boost: Always run on weekdays (SteamDB update within 8h)
          if [ "$BOOST_LEVEL" = "aggressive" ] && [ "$DAY" -ge 1 ] && [ "$DAY" -le 5 ]; then
            echo "‚ö° Aggressive boost active - running regardless of time"
            SHOULD_RUN="true"
          # Normal boost: Run hourly on weekdays (EA blog update within 72h)
          elif [ "$BOOST_LEVEL" = "normal" ] && [ "$DAY" -ge 1 ] && [ "$DAY" -le 5 ]; then
            echo "üîî Normal boost active - running hourly on weekday"
            SHOULD_RUN="true"
          # Regular schedule: Check Mon/Tue work hours (8-20)
          elif [ "$DAY" = "1" ] || [ "$DAY" = "2" ]; then
            if [ "$HOUR" -lt 8 ] || [ "$HOUR" -gt 20 ]; then
              SHOULD_RUN="false"
              echo "‚è∞ Outside work hours (8-20 UTC)"
            fi
          fi
          
          echo "should_run=$SHOULD_RUN" >> $GITHUB_OUTPUT
      
      - name: Check for SDK updates
        if: steps.work_hours.outputs.should_run == 'true'
        id: check
        run: |
          IS_MANUAL="${{ steps.trigger.outputs.is_manual }}"
          
          if [ "$IS_MANUAL" = "true" ]; then
            echo "Portal SDK Update Check"
            echo "=================================================="
          fi
          
          # Fetch remote versions.json
          VERSIONS_URL=$(jq -r '.urls.versions' .github/config.json)
          curl -s -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0" "$VERSIONS_URL" > /tmp/remote-versions.json
          
          REMOTE_VER=$(jq -r '.versions | last | .version' /tmp/remote-versions.json)
          REMOTE_SIZE=$(jq -r '.versions | last | .fileSize // 0' /tmp/remote-versions.json)
          
          # Load local version
          if [ -f "sdk.version.json" ]; then
            LOCAL_VER=$(jq -r '.version // "0"' sdk.version.json)
            LOCAL_SIZE=$(jq -r '.fileSize // .filesize // 0' sdk.version.json)
          else
            LOCAL_VER="0"
            LOCAL_SIZE="0"
          fi
          
          if [ "$IS_MANUAL" = "true" ]; then
            echo "Local version: $LOCAL_VER ($LOCAL_SIZE bytes)"
            echo "Remote version: $REMOTE_VER ($REMOTE_SIZE bytes)"
          fi
          
          # Compare
          UPDATE_NEEDED="false"
          UPDATE_REASON="No changes detected"
          
          if [ "$REMOTE_VER" != "$LOCAL_VER" ]; then
            UPDATE_NEEDED="true"
            UPDATE_REASON="Version changed"
          fi
          
          if [ "$REMOTE_SIZE" != "0" ] && [ "$LOCAL_SIZE" != "0" ] && [ "$REMOTE_SIZE" != "$LOCAL_SIZE" ]; then
            UPDATE_NEEDED="true"
            if [ "$UPDATE_REASON" = "Version changed" ]; then
              UPDATE_REASON="Version and filesize changed"
            else
              UPDATE_REASON="Filesize changed"
            fi
          fi
          
          if [ "$IS_MANUAL" = "true" ]; then
            echo "Update needed: $UPDATE_NEEDED"
            echo "Update reason: $UPDATE_REASON"
          fi
          
          # Cache remote data
          mkdir -p .github/cache
          cp /tmp/remote-versions.json .github/cache/versions.json
          
          # Set outputs
          echo "update_needed=$UPDATE_NEEDED" >> $GITHUB_OUTPUT
          echo "old_version=$LOCAL_VER" >> $GITHUB_OUTPUT
          echo "new_version=$REMOTE_VER" >> $GITHUB_OUTPUT
          echo "old_filesize=$LOCAL_SIZE" >> $GITHUB_OUTPUT
          echo "new_filesize=$REMOTE_SIZE" >> $GITHUB_OUTPUT
          echo "update_reason=$UPDATE_REASON" >> $GITHUB_OUTPUT
          
          if [ "$IS_MANUAL" = "true" ]; then
            echo "=================================================="
            echo "$UPDATE_NEEDED: $UPDATE_REASON"
          fi
      
      - name: Create release of current state
        if: steps.check.outputs.update_needed == 'true' && steps.check.outputs.old_version != '0'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          OLD_VERSION="${{ steps.check.outputs.old_version }}"
          
          echo "üì¶ Creating release archive for v${OLD_VERSION}..."
          
          mkdir -p /tmp/sdk-archive
          
          # Copy SDK files only (exclude .git, .github, .gitignore)
          rsync -av --exclude='.git' --exclude='.github' --exclude='.gitignore' ./ /tmp/sdk-archive/ || echo "No files to archive yet"
          
          # Create ZIP
          cd /tmp/sdk-archive
          if [ "$(ls -A .)" ]; then
            zip -r "../portal-sdk_v${OLD_VERSION}.zip" . > /dev/null
            cd -
            
            # Create git tag
            git tag "portal-sdk_v${OLD_VERSION}" || echo "Tag already exists"
            git push origin "portal-sdk_v${OLD_VERSION}" || echo "Tag push failed or already exists"
            
            # Create GitHub release
            gh release create "portal-sdk_v${OLD_VERSION}" \
              "/tmp/portal-sdk_v${OLD_VERSION}.zip" \
              --title "Portal SDK v${OLD_VERSION}" \
              --notes "Portal SDK version ${OLD_VERSION} - Snapshot before update to ${{ steps.check.outputs.new_version }}" \
              || echo "Release already exists"
            
            echo "‚úÖ Release created"
          else
            echo "‚ÑπÔ∏è  No content to release"
          fi
      
      - name: Download SDK
        if: steps.check.outputs.update_needed == 'true'
        id: download
        run: |
          echo "üì• Downloading Portal SDK..."
          
          DOWNLOAD_URL=$(jq -r '.urls.sdk_download' .github/config.json)
          DOWNLOAD_START=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          wget -O /tmp/PortalSDK.zip \
            --user-agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
            "$DOWNLOAD_URL"
          
          DOWNLOAD_END=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          ZIP_SIZE=$(stat -f%z "/tmp/PortalSDK.zip" 2>/dev/null || stat -c%s "/tmp/PortalSDK.zip")
          ZIP_SIZE_MB=$(echo "scale=2; $ZIP_SIZE / 1024 / 1024" | bc)
          
          echo "download_date=$DOWNLOAD_START" >> $GITHUB_OUTPUT
          echo "zip_size=$ZIP_SIZE" >> $GITHUB_OUTPUT
          echo "zip_size_mb=$ZIP_SIZE_MB" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Downloaded: ${ZIP_SIZE_MB} MB"
      
      - name: Extract SDK
        if: steps.check.outputs.update_needed == 'true'
        run: |
          echo "üìÇ Creating backup for comparison..."
          mkdir -p /tmp/sdk-old
          rsync -av --exclude='.git' --exclude='.github' --exclude='.gitignore' ./ /tmp/sdk-old/ || true
          
          echo "ÔøΩ Extracting new SDK to temporary location..."
          mkdir -p /tmp/sdk-new
          unzip -q /tmp/PortalSDK.zip -d /tmp/sdk-new
          
          echo "üîÑ Syncing only changed files..."
          rsync -av --checksum --delete \
            --exclude='.git' --exclude='.github' --exclude='.gitignore' \
            /tmp/sdk-new/ ./
          
          echo "‚úÖ SDK updated (only changed files written)"
      
      - name: Generate file comparison
        if: steps.check.outputs.update_needed == 'true'
        id: compare
        run: |
          echo "üîç Comparing files..."
          
          mkdir -p .github/cache
          
          OLD_DIR="/tmp/sdk-old"
          
          if [ -d "$OLD_DIR" ] && [ "$(ls -A $OLD_DIR)" ]; then
            OLD_COUNT=$(find "$OLD_DIR" -type f | wc -l)
          else
            OLD_COUNT=0
          fi
          
          NEW_COUNT=$(find . -maxdepth 10 -type f -not -path './.git/*' -not -path './.github/*' | wc -l)
          
          cat > .github/cache/comparison.json << EOF
          {
            "old_version": "${{ steps.check.outputs.old_version }}",
            "new_version": "${{ steps.check.outputs.new_version }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "summary": {
              "old_file_count": $OLD_COUNT,
              "new_file_count": $NEW_COUNT,
              "added_count": 0,
              "deleted_count": 0,
              "modified_count": 0,
              "moved_count": 0,
              "unchanged_count": 0,
              "added": [],
              "deleted": [],
              "modified": [],
              "moved": []
            }
          }
          EOF
          
          echo "‚úÖ Comparison saved"
          cp .github/cache/comparison.json .github/cache/comparison-raw.json
      
      - name: Generate changelog
        if: steps.check.outputs.update_needed == 'true'
        id: changelog
        uses: actions/github-script@v7
        env:
          OLD_VERSION: ${{ steps.check.outputs.old_version }}
          NEW_VERSION: ${{ steps.check.outputs.new_version }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        with:
          script: |
            const fs = require('fs');
            const comparison = JSON.parse(fs.readFileSync('.github/cache/comparison.json', 'utf8'));
            const oldVersion = process.env.OLD_VERSION;
            const newVersion = process.env.NEW_VERSION;
            const apiKey = process.env.GEMINI_API_KEY;
            const summary = comparison.summary || {};
            
            // Basic changelog function
            function createBasicChangelog() {
              const date = new Date().toISOString().split('T')[0];
              let changelog = `# Portal SDK Changelog\n\n## Version ${newVersion}\n**Released**: ${date}\n**Previous version**: ${oldVersion}\n\n`;
              
              if (summary.zip_old_size && summary.zip_new_size) {
                const oldMB = (summary.zip_old_size / 1024 / 1024).toFixed(2);
                const newMB = (summary.zip_new_size / 1024 / 1024).toFixed(2);
                const diff = summary.zip_new_size - summary.zip_old_size;
                const diffMB = (Math.abs(diff) / 1024 / 1024).toFixed(2);
                changelog += `### ZIP File Size\n- **Old**: ${oldMB} MB\n- **New**: ${newMB} MB\n- **Change**: ${diff > 0 ? '+' : ''}${diffMB} MB\n\n`;
              }
              
              changelog += `### Summary\n- **Added**: ${summary.added_count || 0} files\n- **Deleted**: ${summary.deleted_count || 0} files\n- **Modified**: ${summary.modified_count || 0} files\n\n`;
              return changelog;
            }
            
            // If no API key, return basic changelog
            if (!apiKey) {
              core.setOutput('changelog', createBasicChangelog());
              return;
            }
            
            // Build file examples for AI prompt
            let fileExamples = '';
            if (summary.added_count > 0) {
              fileExamples += `\n### Added Files (${summary.added_count} total):\n`;
              (summary.added || []).slice(0, 15).forEach(f => {
                const sizeInfo = f.size ? ` (${(f.size / 1024).toFixed(1)} KB)` : '';
                fileExamples += `- ${f.path}${sizeInfo}\n`;
              });
            }
            if (summary.deleted_count > 0) {
              fileExamples += `\n### Deleted Files (${summary.deleted_count} total):\n`;
              (summary.deleted || []).slice(0, 15).forEach(f => {
                fileExamples += `- ${f.path}\n`;
              });
            }
            if (summary.modified_count > 0) {
              fileExamples += `\n### Modified Files (${summary.modified_count} total):\n`;
              (summary.modified || []).slice(0, 15).forEach(f => {
                let info = '';
                if (f.is_text && f.lines_changed) info += ` - ~${f.lines_changed} lines changed`;
                if (f.old_size && f.new_size) {
                  const diff = f.new_size - f.old_size;
                  info += ` (${diff > 0 ? '+' : ''}${(diff / 1024).toFixed(1)} KB)`;
                }
                fileExamples += `- ${f.path}${info}\n`;
              });
            }
            
            let zipInfo = '';
            if (summary.zip_old_size && summary.zip_new_size) {
              const oldMB = (summary.zip_old_size / 1024 / 1024).toFixed(2);
              const newMB = (summary.zip_new_size / 1024 / 1024).toFixed(2);
              const diff = summary.zip_new_size - summary.zip_old_size;
              const diffMB = (Math.abs(diff) / 1024 / 1024).toFixed(2);
              zipInfo = `\n### ZIP File Size:\n- Old: ${oldMB} MB\n- New: ${newMB} MB\n- Change: ${diff > 0 ? '+' : ''}${diffMB} MB\n`;
            }
            
            const prompt = `You are an expert technical writer analyzing SDK changes for game developers working with Battlefield Portal.\n\nYour task is to analyze the Battlefield Portal SDK update from version ${oldVersion} to version ${newVersion} and create a clear, actionable changelog.\n\n## Context\nThe Battlefield Portal SDK is used by mod developers and content creators to build custom game modes and experiences. Changes can affect:\n- Available game objects and prefabs\n- Python scripting APIs\n- Godot editor plugins and tools\n- Example projects and documentation\n- Asset availability\n\n## Update Data\n${zipInfo}\n\n### File Statistics:\n- Added: ${summary.added_count || 0} files\n- Deleted: ${summary.deleted_count || 0} files\n- Modified: ${summary.modified_count || 0} files\n- Moved/Renamed: ${summary.moved_count || 0} files\n- Unchanged: ${summary.unchanged_count || 0} files\n\n${fileExamples}\n\n## Your Task\nAnalyze these changes and create a concise, developer-friendly changelog in Markdown format with:\n\n1. **Brief Summary** (2-3 sentences): What's the main focus of this update?\n2. **Key Highlights** (bullet points): What are the most important changes developers should know about?\n3. **Potential Impact** (2-3 sentences): How might these changes affect existing projects? What should developers check or update?\n\n## Guidelines\n- Focus on patterns and meaningful changes (e.g., "Added 50 new props to SouthernCalifornia maps" instead of listing all 50 files)\n- Identify if changes are primarily additive (new content) or breaking (removed/modified content)\n- Mention specific folders/categories when they show significant changes (e.g., "Gameplay/Vehicles", "objects/Cairo")\n- Use clear, concise language\n- Keep response under 500 words\n- Use appropriate emojis for visual clarity\n\nGenerate the changelog now:`;
            
            // Call Gemini API
            try {
              const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`,
                {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.7, maxOutputTokens: 1500 }
                  })
                }
              );
              
              const data = await response.json();
              if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                const aiChangelog = `# Portal SDK Changelog\n\n## Version ${newVersion}\n\n` + data.candidates[0].content.parts[0].text;
                core.setOutput('changelog', aiChangelog);
                console.log('AI changelog generated successfully');
              } else {
                core.setOutput('changelog', createBasicChangelog());
                console.log('Gemini response unexpected, using basic changelog');
              }
            } catch (error) {
              core.setOutput('changelog', createBasicChangelog());
              console.log('Gemini request failed, using basic changelog:', error.message);
            }
      
      - name: Update game-SDK version tracker
        if: steps.check.outputs.update_needed == 'true'
        run: |
          CACHE_FILE=".github/cache/game-update-tracker.json"
          NEW_VERSION="${{ steps.check.outputs.new_version }}"
          GAME_VERSION="${{ steps.game_update.outputs.game_version || 'unknown' }}"
          
          if [ -f "$CACHE_FILE" ]; then
            echo "üìù Updating game-SDK version mapping..."
            
            jq ".sdk.last_update_date = \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\" | \
                .sdk.version = \"$NEW_VERSION\" | \
                .sdk.matched_game_version = \"$GAME_VERSION\"" \
                "$CACHE_FILE" > "$CACHE_FILE.tmp" && mv "$CACHE_FILE.tmp" "$CACHE_FILE"
            
            echo "‚úÖ Linked SDK v$NEW_VERSION with game v$GAME_VERSION"
          fi
      
      - name: Commit and push changes
        if: steps.check.outputs.update_needed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add -A
          git commit -m "Update Portal SDK to v${{ steps.check.outputs.new_version }}" || true
          git push
      
      - name: Create GitHub issue for update
        if: steps.check.outputs.update_needed == 'true'
        id: create_issue
        uses: actions/github-script@v7
        with:
          script: |
            const oldVersion = '${{ steps.check.outputs.old_version }}';
            const newVersion = '${{ steps.check.outputs.new_version }}';
            const updateReason = '${{ steps.check.outputs.update_reason }}';
            const changelog = `${{ steps.changelog.outputs.changelog }}`;
            
            const fs = require('fs');
            let comparison = {};
            try {
              comparison = JSON.parse(fs.readFileSync('.github/cache/comparison.json', 'utf8'));
            } catch (e) {}
            
            const issueBody = `## Portal SDK Update Detected
            
            A new version of the Portal SDK has been downloaded and extracted.
            
            ### Version Information
            - **Previous Version**: \`${oldVersion}\`
            - **New Version**: \`${newVersion}\`
            - **Update Reason**: ${updateReason}
            - **Updated**: ${new Date().toISOString()}
            
            ### File Changes
            - **Files in new SDK**: ${comparison.summary?.new_file_count || 'N/A'}
            - **Files in old SDK**: ${comparison.summary?.old_file_count || 'N/A'}
            
            ### Changelog
            
            ${changelog}
            
            ---
            
            **Next Steps:**
            1. Review the changes in this repository
            2. Check the [latest commit](https://github.com/${context.repo.owner}/${context.repo.repo}/commits/main)
            3. Download SDK from [releases](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/tag/portal-sdk_v${newVersion})
            4. Update dependent repositories
            
            *This issue was automatically created by the SDK update workflow.*
            `;
            
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `New SDK Update: Migrating from v${oldVersion} to v${newVersion}`,
              body: issueBody,
              labels: ['sdk-update', 'automated']
            });
            
            console.log(`‚úÖ Created issue #${issue.data.number}`);
            core.setOutput('issue_number', issue.data.number);
      
      - name: Trigger workflow in target repository
        if: steps.check.outputs.update_needed == 'true'
        uses: actions/github-script@v7
        env:
          OLD_VERSION: ${{ steps.check.outputs.old_version }}
          NEW_VERSION: ${{ steps.check.outputs.new_version }}
          CHANGELOG: ${{ steps.changelog.outputs.changelog }}
        with:
          script: |
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('.github/config.json', 'utf8'));
            
            let comparisonRaw = '';
            try {
              comparisonRaw = fs.readFileSync('.github/cache/comparison-raw.json', 'utf8'));
            } catch (e) {}
            
            const changelogAI = process.env.CHANGELOG || '';
            
            const targetRepo = config.github.target_repo || 'YOUR_ORG/target-repo';
            const [targetOwner, targetRepoName] = targetRepo.split('/');
            
            if (targetOwner === 'YOUR_ORG') {
              console.log('‚ö†Ô∏è  Target repository not configured in .github/config.json');
              console.log('   Skipping workflow trigger');
              return;
            }
            
            console.log(`üöÄ Triggering workflow in ${targetRepo}...`);
            
            try {
              await github.rest.repos.createDispatchEvent({
                owner: targetOwner,
                repo: targetRepoName,
                event_type: 'sdk-updated',
                client_payload: {
                  old_version: process.env.OLD_VERSION,
                  new_version: process.env.NEW_VERSION,
                  source_repo: `${context.repo.owner}/${context.repo.repo}`,
                  issue_number: '${{ steps.create_issue.outputs.issue_number }}',
                  comparison_raw: comparisonRaw,
                  changelog_ai: changelogAI,
                  timestamp: new Date().toISOString()
                }
              });
              
              console.log('‚úÖ Workflow triggered successfully');
            } catch (error) {
              console.log('‚ö†Ô∏è  Could not trigger workflow:', error.message);
            }
      
      - name: Summary
        if: steps.check.outputs.update_needed == 'true'
        run: |
          echo "‚úÖ SDK Update Complete"
          echo "Old version: ${{ steps.check.outputs.old_version }}"
          echo "New version: ${{ steps.check.outputs.new_version }}"
          echo "Issue: #${{ steps.create_issue.outputs.issue_number }}"
